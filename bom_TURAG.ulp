#require 6.0500 //Version 6.5.0

#usage 	"<b>Teileliste exportieren</b>"
		"<p>"
		"Erzeugt die Teileliste (Bill of Material) eines Projektes"
		"<p>"


///start define
//special attributes
string NO_ORDER = "NOORDER";
string PROTOTYPE = "PROTOTYPE";
string KEEP_AS_IS = "KEEP_AS_IS";
//providers
numeric string provider_names[] = {"FARNELL","REICHELT","DIGIKEY","WUERTH"}; ///Only these attributes are important; all other will be ignored
int PROVIDER_COUNT	= 4;
//pathes
string ORDER_CODE_RELPATH = "order_codes/";
///end define

enum {output_text, output_farnell, output_reichelt, output_DigiKey};
// arrays for order codes from file
numeric string oc_device[], oc_package[], oc_value[], oc_code[];
int oc_index[], oc_count;
//arrays for order codes from schematic
numeric string part_name[], part_value[], part_device[], part_package[], part_headline[], part_description[], part_attributes[];
int part_amount[];
int num_parts = 0, output_format;

string get_pwd(void){
	int index = strrchr(argv[0], '\\');
	if (index < 0){
		index = strrchr(argv[0], '/');
	}
	return strsub(argv[0], 0, index + 1 );
}

/**
 * \brief Collects part data from all files in ORDER_CODE_RELPATH directory and subdirectories
 */
void collectFilePartData(void){
	string msg;
	string files[], lines[], line[], path;
	int filecount, line_count, line_nargs;
	
	oc_count = 0;
	
	path = get_pwd(); ///get the path of the directory of this file
	path += ORDER_CODE_RELPATH + "*.txt";
	filecount = fileglob(files,path);
	fileerror(); //reset error buffer
	for (int i=0;i<filecount;i++){
		line_count = fileread(lines, files[i]);
		for (int line_nr=0;line_nr<line_count;line_nr++){
			if(strlen(lines[line_nr]) == 0){
				//ignore empty lines
				continue;
			}
			if(strchr(lines[line_nr],'#') == 0){
				//line starts with a '#' -> ignore
				continue;
			}
			line_nargs = strsplit(line, lines[line_nr], ';');
			if( line_nargs < 4 ){
				string err;
				sprintf(err, ":File '%s' has not enough arguments in line %d.", files[i], line_nr+1);
				dlgMessageBox(err);
				exit(-1);
			}
			if( strlen(line[0]) == 0){
				string err;
				sprintf(err, ":File '%s' has no device argument in line %d.", files[i], line_nr+1);
				dlgMessageBox(err);
				exit(-1);
			}
			if( strlen(line[1]) == 0){
				string err;
				sprintf(err, ":File '%s' has no package argument in line %d.", files[i], line_nr+1);
				dlgMessageBox(err);
				exit(-1);
			}
			
			for(int j=0; j<(line_nargs-3); j++){
				oc_device[oc_count] = line[0];
				oc_package[oc_count] = line[1];
				oc_value[oc_count] = line[2];
				oc_code[oc_count] = line[j+3];
				++oc_count;
			}
		}
	}
	
	sort(oc_count, oc_index, oc_device, oc_package, oc_value, oc_code);
	//print for debug
	sprintf(msg, "%d codes found", oc_count);
	for(i=0; i<oc_count; i++){
		sprintf(msg, "%s\n%d|%s|%s|%s|%s", msg, oc_index[i], oc_device[i], oc_package[i], oc_value[i], oc_code[i]);
	}
	dlgMessageBox(msg);
}

/**
 * \brief Updates and collects part data from schematic
 */
void updateCollectPartData(){
	int printed_attr_error = 0;
	
	schematic(schem){
		schem.parts(part){
			if(part.device.package){
				int keep_as_is = 0;
				
				///get the properties
				part_name[num_parts] = part.name;
				part_value[num_parts] = part.value;
				part_device[num_parts] = part.device.name;
				part_package[num_parts] = part.device.package.name;
				part_headline[num_parts] = part.device.headline;
				part_description[num_parts] = part.device.description;
				part_attributes[num_parts] = "";
				part_amount[num_parts]=1;
				
				///search for special attributes
				part.attributes(attribute){
					if(attribute.name == KEEP_AS_IS){
						keep_as_is = 1;
					}
				}
				///update attributes
				if(!keep_as_is){
					part.attributes(attribute){
						
					}
				}
			}
		}
	}
} //updateCollectPartData()

/*void GenerateList(void){
	int index[];
	int ind1, ind2, amount = 0;
	string qty;

	sort(num_parts, index, part_value, part_device, part_headline, part_package, part_attributes, part_name);

	row = 0;
	list_rows[row] = "Menge\tWert\tBauelement\tPackage\t";
	for(int i=0;i<PROVIDER_COUNT;i++){
		list_rows[row] += provider_names[i] + "\t";
	}
	list_rows[row++] += "Beschreibung\tBauteile";


	///accumulate the parts and get the amount if there is more than one part with the same properties
	for(int i1 = 0, i2 = 1; i2<=num_parts; i2++){
		int is_prototype = 0;
		ind1 = index[i1]; //first part with same properties
		ind2 = index[i2]; //the other(last) part with same properties
		if(i1 == (i2-1)){
			amount = part_amount[ind1];
		}

		if( (i2 != num_parts) && (part_value[ind1] == part_value[ind2]) && (part_package[ind1] == part_package[ind2]) && (part_device[ind1] == part_device[ind2]) && (part_attributes[ind1] == part_attributes[ind2])){
			amount += part_amount[ind2];
			continue;
		}

		sprintf(qty, "%d", (amount)); ///calculate quantity of same parts
		amount = 0;

		list_rows[row] = qty + "\t" + part_value[ind1] + "\t" + part_device[ind1] + "\t" + part_package[ind1] + "\t" + part_attributes[ind1] + part_headline[ind1] + "\t";

		///list the part names
		do{
			list_rows[row] += part_name[index[i1]];
			if(i1 < (i2-1)) list_rows[row] += ",";
		}while(++i1<i2);



		row++;
	}


}

string MakeTextOutput(void){
	string out = "", line, split[];
	int i, width[], headers;

	headers = strsplit(split,list_rows[0],'\t');

	///get the maximum width for each column
	for(i=0;list_rows[i];i++){
		strsplit(split,list_rows[i],'\t');
		for(int j=0;j<headers;j++){
			width[j] = max(width[j], strlen(split[j]));
		}
	}

	///print the rows
	for(i=0;i<row;i++){
		line = "";
		int n = strsplit(split,list_rows[i],'\t');

		if(i == 0){
			headers = n;
		} else {
			n = headers; /// for the Rows with missing cells
		}

		for(int j=0;j<n;j++){
			while(strlen(split[j]) <= width[j] ){ ///add spaces --> every row in every column the same width
				split[j] += " ";
			}
			line += split[j] + "|";
		}

		if( i == 0 ){ ///the '-------' below the heading
			int len = strlen(line);
			line += "\n";
			for(int j=0;j<=len;j++){
				line += "-";
			}
		}

		out += line + "\n";
	}

	return out;
}

string MakeFarnellOutput(void){ ///Farnell Syntax: 'number, quantity'
	string out = "Bestellnummer,Menge\n", split[];
	int farnell_index, i, j;

	strsplit(split, list_rows[0], '\t');
	for(i=0;list_rows[i];i++){ ///get the index of the Farnell-number
		if (split[i] == "FARNELL"){
			farnell_index = i;
			break;
		}
	}

	for(i=1;i<row;i++){
		strsplit(split, list_rows[i], '\t');
		if(split[farnell_index] != ""){
			if( strtol(split[0]) ) out += split[farnell_index] + "," + split[0] + "\n"; ///split[0] is the quantity; make only an output, when there is any needed part
		}
	}

	return out;
}

string MakeReicheltOutput(void){///Reichelt-Syntax: 'number;quantity'
	string out = "", split[];
	int reichelt_index, i, j;

	strsplit(split, list_rows[0], '\t');
	for(i=0;list_rows[i];i++){ ///get the index of the Reichelt-number
		if (split[i] == "REICHELT"){
			reichelt_index = i;
			break;
		}
	}

	for(i=1;i<row;i++){
		strsplit(split, list_rows[i], '\t');
		if(split[reichelt_index] != ""){
			if( strtol(split[0]) ) out += split[reichelt_index] + ";" + split[0] + "\n";///split[0] is the quantity; make only an output, when there is any needed part
		}
	}

	return out;
}

string MakeDigikeyOutput(void){///Digikey-Syntax: 'quantity,number'
	string out = "", split[];
	int digikey_index, i, j;

	strsplit(split, list_rows[0], '\t');
	for(i=0;list_rows[i];i++){ ///get the index of the Digikey-number
		if (split[i] == "DIGIKEY"){
			digikey_index = i;
			break;
		}
	}

	for(i=1;i<row;i++){
		strsplit(split, list_rows[i], '\t');
		if(split[digikey_index] != ""){
			if( strtol(split[0]) ) out += split[0] + "," + split[digikey_index] + "\n";///split[0] is the quantity; make only an output, when there is any needed part
		}
	}

	return out;
}

string MakeOutput(void){ ///Choose the Output-Format
	switch(output_format){
		case output_text: return MakeTextOutput(); break;
		case output_farnell: return MakeFarnellOutput(); break;
		case output_reichelt: return MakeReicheltOutput(); break;
		case output_DigiKey: return MakeDigikeyOutput(); break;
	}
	return "";
}

void SaveData(void){
	string file_name;
	schematic(schem) file_name = filesetext(schem.name,""); ///filename is the name of the schematic; file will be stored in the folder of schematic

	switch(output_format){
		case output_farnell: file_name += "_farnell"; break;
		case output_reichelt: file_name += "_reichelt"; break;
		case output_DigiKey: file_name += "_digikey"; break;
	}

	file_name += ".txt";

	string path = dlgFileSave("Teileliste speichern", file_name ); ///Open save-Dialog

	if (path){ ///do not save if the path is empty
		fileerror();
		string s[];
		if (!fileglob (s, path) || dlgMessageBox ("!Datei existiert - überschreiben?", "+&Ja", "-&Nein") == 0){ ///check, whether the file already exists and ask for overwriting
			output (path, "wt"){ ///open the file
				printf ("%s", MakeOutput()); ///write to the file
			}
		}

		if (fileerror()){ ///there was an error while writing the file
			dlgMessageBox(":Unable to save file");
			return;
		}
	}
}

void ViewList(void){
	dlgDialog("Voransicht"){ ///The window
		dlgVBoxLayout{ ///box to stack it vertically
			string s = MakeOutput();
			s = "<pre>" + s + "</pre>";
			dlgTextView(s); ///Text box
			dlgHBoxLayout{ ///box for buttons (stack it horizontally)
				dlgStretch(1); ///stretch: the buttons should be in the middle
				dlgPushButton("+&Speichern...") SaveData();
				dlgPushButton("+Schließen") dlgReject();
				dlgStretch(1); ///stretch: the buttons should be in the middle
			}
		}
	};
}*/

/// ~~~BEGIN of the ULP ~~~~~~

if (!schematic) ///this ULP only works in Schematicss
{
  dlgMessageBox (":Die Bauteilliste kann nur innerhalb eines Schaltplanes erstellt werden.");
  exit (1);
}

collectFilePartData();
updateCollectPartData();

/*GenerateList();

//string str; sprintf(str, "parts: %d",num_parts); dlgMessageBox(str);

dlgDialog("Teileliste"){ ///Main Dialog

	int selected = -2, sort_col = 2, format;
	string head = ""; ///empty, because it will be generated in 'GenerateList()' as the row[0]

	dlgVBoxLayout { ///Box to stack it vertically
		dlgListView (head, list_rows, selected);//, sort_col); ///List
		dlgHBoxLayout{ ///Box for the output-format
			dlgGroup("Ausgabe-Format"){
				dlgRadioButton("&Text", output_format);
				dlgRadioButton("&Farnell-Bestellliste", output_format);
				dlgRadioButton("&Reichelt-Bestellliste", output_format);
				dlgRadioButton("&DigiKey-Bestellliste", output_format);
			}
			dlgStretch(1);
		}
		dlgHBoxLayout{ ///box to stack the buttons horizontally
			//dlgStretch(1);
			dlgPushButton("&Voransicht") ViewList();
			dlgPushButton("+&Speichern...") SaveData();
			dlgPushButton("S&chließen") dlgReject();
			dlgStretch(1);
		}
	}


};*/

